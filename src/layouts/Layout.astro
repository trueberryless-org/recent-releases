---
interface Props {
  title?: string;
}

const { title = "Releases" } = Astro.props;
---

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width" />
    <link rel="icon" type="image/png" href="/favicon.png" />
    <meta name="color-scheme" content="dark light" />
    <title>{title}</title>
  </head>
  <body>
    <slot />
    <canvas id="plum-canvas"></canvas>
    <button id="scroll-to-top" title="Scroll to top">
      <svg
        xmlns="http://www.w3.org/2000/svg"
        width="24"
        height="24"
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
        stroke-linecap="round"
        stroke-linejoin="round"
      >
        <polyline points="18 15 12 9 6 15"></polyline>
      </svg>
    </button>

    <script>
      // Dark mode toggle
      const darkModeKey = "vueuse-color-scheme";

      // Initialize dark mode from localStorage
      function initDarkMode() {
        const stored = localStorage.getItem(darkModeKey);
        const prefersDark = window.matchMedia(
          "(prefers-color-scheme: dark)"
        ).matches;
        const isDark = stored === "dark" || (!stored && prefersDark);

        if (isDark) {
          document.documentElement.classList.add("dark");
        }
      }

      initDarkMode();

      // Handle dark mode toggle
      document.addEventListener("DOMContentLoaded", () => {
        const toggleButton = document.getElementById("dark-toggle");
        if (toggleButton) {
          toggleButton.addEventListener("click", () => {
            const isDark = document.documentElement.classList.toggle("dark");
            localStorage.setItem(darkModeKey, isDark ? "dark" : "light");
          });
        }
      });

      // Scroll to top functionality
      const scrollBtn = document.getElementById("scroll-to-top");
      if (scrollBtn) {
        function updateScrollButton() {
          if (window.scrollY > 300) {
            scrollBtn.classList.add("visible");
          } else {
            scrollBtn.classList.remove("visible");
          }
        }

        window.addEventListener("scroll", updateScrollButton);
        updateScrollButton();

        scrollBtn.addEventListener("click", () => {
          window.scrollTo({
            top: 0,
            behavior: "smooth",
          });
        });
      }

      // Art Plum Canvas
      const canvas = document.getElementById("plum-canvas");
      if (canvas) {
        const r180 = Math.PI;
        const r90 = Math.PI / 2;
        const r15 = Math.PI / 12;
        const color = "#88888825";
        const { random } = Math;
        const MIN_BRANCH = 30;
        const len = 6;

        function initCanvas(canvas, width, height) {
          const ctx = canvas.getContext("2d");
          const dpr = window.devicePixelRatio || 1;
          const bsr = 1;
          const dpi = dpr / bsr;

          canvas.style.width = `${width}px`;
          canvas.style.height = `${height}px`;
          canvas.width = dpi * width;
          canvas.height = dpi * height;
          ctx.scale(dpi, dpi);

          return { ctx, dpi };
        }

        function polar2cart(x, y, r, theta) {
          const dx = r * Math.cos(theta);
          const dy = r * Math.sin(theta);
          return [x + dx, y + dy];
        }

        const size = {
          width: window.innerWidth,
          height: window.innerHeight,
        };
        const { ctx } = initCanvas(canvas, size.width, size.height);

        let steps = [];
        let prevSteps = [];
        let stopped = false;

        const step = (x, y, rad, counter = { value: 0 }) => {
          const length = random() * len;
          counter.value += 1;

          const [nx, ny] = polar2cart(x, y, length, rad);

          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(nx, ny);
          ctx.stroke();

          const rad1 = rad + random() * r15;
          const rad2 = rad - random() * r15;

          if (
            nx < -100 ||
            nx > size.width + 100 ||
            ny < -100 ||
            ny > size.height + 100
          ) {
            return;
          }

          const rate = counter.value <= MIN_BRANCH ? 0.8 : 0.5;

          if (random() < rate) steps.push(() => step(nx, ny, rad1, counter));
          if (random() < rate) steps.push(() => step(nx, ny, rad2, counter));
        };

        let lastTime = performance.now();
        const interval = 1000 / 40;
        let animationId;

        const frame = () => {
          if (performance.now() - lastTime >= interval) {
            prevSteps = steps;
            steps = [];
            lastTime = performance.now();

            if (!prevSteps.length) {
              stopped = true;
              cancelAnimationFrame(animationId);
              return;
            }

            prevSteps.forEach((i) => {
              if (random() < 0.5) steps.push(i);
              else i();
            });
          }
          animationId = requestAnimationFrame(frame);
        };

        const randomMiddle = () => random() * 0.6 + 0.2;

        function startDrawing() {
          ctx.clearRect(0, 0, size.width, size.height);
          ctx.lineWidth = 1;
          ctx.strokeStyle = color;
          prevSteps = [];
          steps = [
            () => step(randomMiddle() * size.width, -5, r90),
            () => step(randomMiddle() * size.width, size.height + 5, -r90),
            () => step(-5, randomMiddle() * size.height, 0),
            () => step(size.width + 5, randomMiddle() * size.height, r180),
          ];
          if (size.width < 500) steps = steps.slice(0, 2);
          stopped = false;
          animationId = requestAnimationFrame(frame);
        }

        startDrawing();

        window.addEventListener("resize", () => {
          size.width = window.innerWidth;
          size.height = window.innerHeight;
          const { ctx: newCtx } = initCanvas(canvas, size.width, size.height);
          Object.assign(ctx, newCtx);
          if (stopped) startDrawing();
        });
      }
    </script>
  </body>
</html>

<style is:global>
  * {
    box-sizing: border-box;
  }

  html,
  body {
    height: 100%;
    margin: 0;
    padding: 0;
    font-family:
      -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu,
      Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
  }

  html {
    background: white;
    color: #1a1a1a;
  }

  html.dark {
    color-scheme: dark;
    background: #121212;
    color: #e5e5e5;
  }

  a {
    color: inherit;
    text-decoration: none;
  }

  a:hover {
    text-decoration: underline;
  }

  #plum-canvas {
    pointer-events: none;
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    top: 0;
    z-index: -1;
    mask-image: radial-gradient(circle, transparent, black);
    -webkit-mask-image: radial-gradient(circle, transparent, black);
  }

  @media print {
    #plum-canvas,
    #scroll-to-top {
      display: none !important;
    }
  }

  #scroll-to-top {
    position: fixed;
    bottom: 0.75rem;
    right: 0.75rem;
    z-index: 100;
    height: 2.5rem;
    width: 2.5rem;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    border: none;
    background: transparent;
    cursor: pointer;
    opacity: 0;
    pointer-events: none;
    transition:
      opacity 0.3s,
      background 0.3s;
    color: inherit;
  }

  #scroll-to-top.visible {
    opacity: 0.3;
    pointer-events: auto;
  }

  #scroll-to-top:hover {
    background: rgba(136, 136, 136, 0.2);
    opacity: 1 !important;
  }

  #scroll-to-top svg {
    width: 1.25rem;
    height: 1.25rem;
  }
</style>
